<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
  <title>Car Dodge 3D (Mobile Optimized)</title>
  <style>
    html, body {
      margin:0; height:100%; overflow:hidden;
      background:#070912; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      touch-action: none;
      overscroll-behavior: none;
    }
    canvas { display:block; }

    /* HUD */
    .hud {
      position: fixed; left: 10px; top: 10px; z-index: 10;
      color: #eaf0ff; text-shadow: 0 2px 12px rgba(0,0,0,.6);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      min-width: 170px;
      max-width: calc(100vw - 20px);
    }
    .hud .row { display:flex; justify-content:space-between; gap:10px; font-size: 14px; }
    .hud .big { font-size: 18px; font-weight: 800; margin-top: 6px; }
    .hint { opacity: .9; font-size: 12px; margin-top: 6px; line-height: 1.25; }

    /* Mobile controls */
    .controls {
      position: fixed; left: 0; right: 0; bottom: 0;
      display: none; z-index: 12;
      padding: 14px 12px calc(14px + env(safe-area-inset-bottom));
      pointer-events: none;
    }
    .controls .bar {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      pointer-events: auto;
    }
    .btn {
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      border-radius: 18px;
      padding: 14px 10px;
      text-align: center;
      font-weight: 800;
      color: #f4f7ff;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
    }
    .btn:active { transform: translateY(1px) scale(0.99); background: rgba(255,255,255,0.12); }
    .btn small { display:block; font-weight: 650; opacity: .85; margin-top: 4px; }

    /* Drag hint */
    .dragTip {
      position: fixed;
      left: 50%; transform: translateX(-50%);
      bottom: calc(86px + env(safe-area-inset-bottom));
      z-index: 11;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 999px;
      padding: 8px 12px;
      color: #eaf0ff;
      font-size: 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      opacity: .9;
      display:none;
    }

    /* Overlay (start / game over) */
    .overlay {
      position: fixed; inset: 0; z-index: 20;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 700px at 50% 40%, rgba(130,160,255,0.18), rgba(0,0,0,0.78));
      color: #eef3ff;
      padding: 18px;
    }
    .card {
      width: min(560px, 92vw);
      border-radius: 22px;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 30px 90px rgba(0,0,0,.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      padding: 16px;
    }
    .card h1 { margin: 4px 0 8px; font-size: 22px; }
    .card p { margin: 10px 0; opacity: .95; line-height: 1.35; }
    .pill {
      display:inline-block; padding: 6px 10px; border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 12px; margin-right: 8px; margin-bottom: 8px;
    }
    .cta {
      margin-top: 12px;
      display:flex; gap: 10px; flex-wrap: wrap;
    }
    .cta button {
      border: 0; border-radius: 16px; padding: 12px 14px;
      font-weight: 900; cursor:pointer;
      background: linear-gradient(135deg, rgba(140,170,255,0.95), rgba(90,230,255,0.92));
      color: #081020;
      box-shadow: 0 16px 40px rgba(20,120,255,.25);
    }
    .cta button.secondary{
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      color: #f4f7ff;
      box-shadow: none;
    }
    .footerNote { margin-top: 10px; font-size: 12px; opacity: .9; }

    @media (pointer: coarse) {
      .controls { display:block; }
      .dragTip { display:block; }
      .hint { display:none; }
      .hud { left: 8px; top: 8px; padding: 9px 11px; }
      .hud .row { font-size: 13px; }
      .hud .big { font-size: 16px; }
    }
  </style>
</head>
<body>
  <div class="hud" id="hud">
    <div class="row"><span>Score</span><strong id="score">0</strong></div>
    <div class="row"><span>Velocidade</span><strong id="speed">0</strong></div>
    <div class="big" id="status">Pronto</div>
    <div class="hint">PC: ‚Üê ‚Üí ou A/D ‚Ä¢ Espa√ßo: turbo<br/>Celular: bot√µes + arrastar</div>
  </div>

  <div class="dragTip" id="dragTip">üì± Arraste o dedo pra virar</div>

  <div class="controls" aria-hidden="true">
    <div class="bar">
      <div class="btn" id="btnLeft">‚Üê<small>Esq</small></div>
      <div class="btn" id="btnTurbo">‚ü°<small>Turbo</small></div>
      <div class="btn" id="btnRight">‚Üí<small>Dir</small></div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <div>
        <span class="pill">3D ‚Ä¢ Three.js</span>
        <span class="pill">Desvie dos obst√°culos</span>
        <span class="pill">PC + Celular</span>
      </div>
      <h1 id="title">Car Dodge 3D</h1>
      <p id="line1">
        Desvie dos blocos na estrada. Quanto mais tempo voc√™ sobreviver,
        mais r√°pido fica.
      </p>
      <p id="line2" style="margin-top:12px">
        <strong>Controles:</strong><br/>
        PC: <b>A/D</b> ou <b>‚Üê/‚Üí</b> ‚Ä¢ <b>Espa√ßo</b> = Turbo<br/>
        Celular: bot√µes + <b>arrastar</b> na tela
      </p>
      <div class="cta">
        <button id="playBtn">Jogar</button>
      </div>
      <div class="footerNote" id="bestNote"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    // ----------------- Mobile/Perf detection -----------------
    const isCoarse = matchMedia("(pointer: coarse)").matches;
    const isSmall = Math.min(innerWidth, innerHeight) < 520;
    const lowPower = isCoarse || isSmall;

    // ----------------- Renderer -----------------
    const renderer = new THREE.WebGLRenderer({
      antialias: !lowPower,             // mobile: antialias off pra ganhar FPS
      alpha: false,
      powerPreference: lowPower ? "low-power" : "high-performance"
    });
    const dprCap = lowPower ? 1.35 : 2.0;  // cap de resolu√ß√£o no celular
    renderer.setPixelRatio(Math.min(devicePixelRatio, dprCap));
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = !lowPower;           // sombras pesam
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Prevent gestures on canvas
    renderer.domElement.style.touchAction = "none";

    // ----------------- Scene/Camera -----------------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x070912, 10, lowPower ? 75 : 90);

    const camera = new THREE.PerspectiveCamera(65, innerWidth / innerHeight, 0.1, 220);
    camera.position.set(0, 4.2, 10);

    // ----------------- Lights -----------------
    scene.add(new THREE.HemisphereLight(0x9fb6ff, 0x0b1020, 0.9));

    const keyLight = new THREE.DirectionalLight(0x99ccff, 1.1);
    keyLight.position.set(6, 10, 6);
    keyLight.castShadow = !lowPower;
    if (!lowPower) {
      keyLight.shadow.mapSize.set(1024, 1024);
      keyLight.shadow.camera.left = -18;
      keyLight.shadow.camera.right = 18;
      keyLight.shadow.camera.top = 18;
      keyLight.shadow.camera.bottom = -18;
    }
    scene.add(keyLight);

    const rim = new THREE.PointLight(0x66ffee, 0.95, 45, 2);
    rim.position.set(-6, 4, -8);
    scene.add(rim);

    // ----------------- Ground / Road -----------------
    const roadGroup = new THREE.Group();
    scene.add(roadGroup);

    const roadMat = new THREE.MeshStandardMaterial({
      color: 0x0d1530,
      roughness: 0.55,
      metalness: 0.15,
      emissive: 0x02040b,
      emissiveIntensity: 0.35
    });

    const roadGeo = new THREE.BoxGeometry(10, 0.4, 26);
    const roadPieces = [];
    for (let i = 0; i < 5; i++) {
      const road = new THREE.Mesh(roadGeo, roadMat);
      road.position.set(0, -0.6, -i * 26);
      road.receiveShadow = !lowPower;
      roadGroup.add(road);
      roadPieces.push(road);
    }

    // Lane lights (less on mobile)
    const laneLights = new THREE.Group();
    scene.add(laneLights);

    const laneLightMat = new THREE.MeshStandardMaterial({
      color: 0x77a6ff,
      emissive: 0x77a6ff,
      emissiveIntensity: 1.0,
      roughness: 0.6,
      metalness: 0.0
    });

    const laneLightGeo = new THREE.CapsuleGeometry(0.06, 0.25, 6, 12);
    const laneLightZSpacing = 2.2;
    const laneLeftX = -4.7, laneRightX = 4.7;
    const laneLightCount = lowPower ? 26 : 40;
    const laneLightMeshes = [];
    for (let i = 0; i < laneLightCount; i++) {
      const z = -i * laneLightZSpacing;
      const left = new THREE.Mesh(laneLightGeo, laneLightMat);
      left.position.set(laneLeftX, -0.35, z);
      left.rotation.x = Math.PI / 2;
      const right = new THREE.Mesh(laneLightGeo, laneLightMat);
      right.position.set(laneRightX, -0.35, z);
      right.rotation.x = Math.PI / 2;

      laneLights.add(left, right);
      laneLightMeshes.push(left, right);
    }

    // Stars (less on mobile)
    const starsGeo = new THREE.BufferGeometry();
    const starCount = lowPower ? 420 : 900;
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      starPos[i*3+0] = (Math.random() - 0.5) * 140;
      starPos[i*3+1] = Math.random() * 60 + 6;
      starPos[i*3+2] = -Math.random() * 160;
    }
    starsGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
    const starsMat = new THREE.PointsMaterial({ size: 0.06, transparent: true, opacity: 0.8 });
    const stars = new THREE.Points(starsGeo, starsMat);
    scene.add(stars);

    // ----------------- Player car -----------------
    const car = new THREE.Group();
    scene.add(car);

    const bodyMat = new THREE.MeshStandardMaterial({
      color: 0x2c6bff, roughness: 0.35, metalness: 0.65,
      emissive: 0x071235, emissiveIntensity: 0.25
    });
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.25, 0.45, 2.2), bodyMat);
    body.position.y = 0.1;
    body.castShadow = !lowPower;
    car.add(body);

    const cabinMat = new THREE.MeshStandardMaterial({
      color: 0x111a2e, roughness: 0.15, metalness: 0.2,
      emissive: 0x0b1a2a, emissiveIntensity: 0.6
    });
    const cabin = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.38, 1.0), cabinMat);
    cabin.position.set(0, 0.45, -0.15);
    cabin.castShadow = !lowPower;
    car.add(cabin);

    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x070a12, roughness: 0.9, metalness: 0.0 });
    const wheelGeo = new THREE.CylinderGeometry(0.22, 0.22, 0.18, 16);
    function wheel(x, z) {
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z = Math.PI / 2;
      w.position.set(x, -0.05, z);
      w.castShadow = !lowPower;
      car.add(w);
      return w;
    }
    const w1 = wheel(-0.55,  0.75);
    const w2 = wheel( 0.55,  0.75);
    const w3 = wheel(-0.55, -0.75);
    const w4 = wheel( 0.55, -0.75);

    const underMat = new THREE.MeshStandardMaterial({
      color: 0x00ffd0, emissive: 0x00ffd0, emissiveIntensity: 1.2,
      transparent: true, opacity: 0.35, roughness: 0.6, metalness: 0.0
    });
    const under = new THREE.Mesh(new THREE.CircleGeometry(0.9, 20), underMat);
    under.rotation.x = -Math.PI / 2;
    under.position.y = -0.25;
    car.add(under);

    car.position.set(0, 0, 2.5);

    // ----------------- Obstacles (pool + despawn) -----------------
    const obstacleMat = new THREE.MeshStandardMaterial({
      color: 0xff3d6e, roughness: 0.35, metalness: 0.25,
      emissive: 0x2a000f, emissiveIntensity: 0.6
    });
    const ringMat = new THREE.MeshStandardMaterial({
      color: 0xff7aa2, emissive: 0xff2b6b, emissiveIntensity: 0.7,
      roughness: 0.55, metalness: 0.1
    });

    function buildObstacle() {
      const g = new THREE.Group();
      const block = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.0, 1.2), obstacleMat);
      block.position.y = 0.2;
      block.castShadow = !lowPower;
      g.add(block);

      const ring = new THREE.Mesh(new THREE.TorusGeometry(0.45, 0.10, 10, 18), ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.8;
      ring.castShadow = !lowPower;
      g.add(ring);

      g.userData.radius = 0.78; // colis√£o mais justa
      return g;
    }

    const obstacles = [];
    const pool = [];
    const lanes = [-2.2, 0, 2.2];

    function getObstacle() {
      const o = pool.pop() || buildObstacle();
      o.visible = true;
      o.userData.spin = (Math.random() * 0.9 + 0.35) * (Math.random() < 0.5 ? -1 : 1);
      scene.add(o);
      obstacles.push(o);
      return o;
    }

    function releaseObstacle(o) {
      o.visible = false;
      scene.remove(o);
      pool.push(o);
    }

    // ----------------- UI elements -----------------
    const overlay = document.getElementById("overlay");
    const playBtn = document.getElementById("playBtn");
    const scoreEl = document.getElementById("score");
    const speedEl = document.getElementById("speed");
    const statusEl = document.getElementById("status");
    const bestNote = document.getElementById("bestNote");
    const titleEl = document.getElementById("title");
    const line1El = document.getElementById("line1");
    const line2El = document.getElementById("line2");
    const dragTip = document.getElementById("dragTip");

    let best = Number(localStorage.getItem("car_dodge_best") || 0);
    bestNote.textContent = best ? `Melhor: ${best}` : "";

    // ----------------- Game state -----------------
    let running = false;
    let score = 0;
    let baseSpeed = 12;
    let speed = baseSpeed;
    let difficulty = 0;

    let turbo = false;
    let turboEnergy = 1;   // 0..1

    let steer = 0;         // -1..1
    let laneX = 0;

    // "Horizon spawn" system:
    let furthestZ = -60;   // obstacle farthest ahead (negative)
    const horizon = lowPower ? 95 : 120; // how far ahead we keep obstacles

    // ----------------- Input (keyboard + buttons + drag) -----------------
    const keys = { left:false, right:false, turbo:false };

    addEventListener("keydown", (e) => {
      if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = true;
      if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = true;
      if (e.code === "Space") keys.turbo = true;
      if (e.code === "Enter" && !running) startGame();
    });
    addEventListener("keyup", (e) => {
      if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = false;
      if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = false;
      if (e.code === "Space") keys.turbo = false;
    });

    // mobile buttons (hold)
    const btnLeft = document.getElementById("btnLeft");
    const btnRight = document.getElementById("btnRight");
    const btnTurbo = document.getElementById("btnTurbo");

    function bindHold(btn, onDown, onUp) {
      const down = (e)=>{ e.preventDefault(); onDown(); btn.setPointerCapture?.(e.pointerId); };
      const up = (e)=>{ e.preventDefault(); onUp(); };
      btn.addEventListener("pointerdown", down, { passive:false });
      btn.addEventListener("pointerup", up, { passive:false });
      btn.addEventListener("pointercancel", up, { passive:false });
      btn.addEventListener("pointerleave", up, { passive:false });
    }
    bindHold(btnLeft,  ()=> keys.left = true,  ()=> keys.left = false);
    bindHold(btnRight, ()=> keys.right = true, ()=> keys.right = false);
    bindHold(btnTurbo, ()=> keys.turbo = true, ()=> keys.turbo = false);

    // Drag steering (touch-friendly)
    let dragging = false;
    let dragStartX = 0;
    let dragBase = 0;

    renderer.domElement.addEventListener("pointerdown", (e) => {
      // ignore if overlay visible
      if (overlay.style.display !== "none") return;
      dragging = true;
      dragStartX = e.clientX;
      dragBase = laneX;
      renderer.domElement.setPointerCapture?.(e.pointerId);
    }, { passive:false });

    renderer.domElement.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      // convert pixels to lane movement
      const dx = (e.clientX - dragStartX);
      const scale = (Math.min(innerWidth, innerHeight) / 320); // natural on any screen
      const delta = (dx / (120 * scale)); // tweak sensitivity
      laneX = THREE.MathUtils.clamp(dragBase + delta * 3.2, -2.7, 2.7);
      // while dragging, don't force keys steering too much
    }, { passive:false });

    renderer.domElement.addEventListener("pointerup", () => { dragging = false; }, { passive:true });
    renderer.domElement.addEventListener("pointercancel", () => { dragging = false; }, { passive:true });

    // ----------------- Helpers -----------------
    function resetWorld() {
      // clear obstacles
      for (const o of obstacles) releaseObstacle(o);
      obstacles.length = 0;

      score = 0;
      difficulty = 0;
      speed = baseSpeed;
      turbo = false;
      turboEnergy = 1;

      car.position.set(0, 0, 2.5);
      laneX = 0;
      steer = 0;

      // road reset
      for (let i = 0; i < roadPieces.length; i++) roadPieces[i].position.z = -i * 26;

      // lane lights reset
      let idx = 0;
      for (let i = 0; i < laneLightCount; i++) {
        const z = -i * laneLightZSpacing;
        laneLightMeshes[idx++].position.z = z;
        laneLightMeshes[idx++].position.z = z;
      }

      // spawn baseline
      furthestZ = -60;
      // ensure enough ahead
      while (Math.abs(furthestZ) < horizon) spawnObstacleAhead();
    }

    function startGame() {
      titleEl.textContent = "Car Dodge 3D";
      line1El.textContent = "Desvie dos blocos na estrada. Quanto mais tempo voc√™ sobreviver, mais r√°pido fica.";
      line2El.innerHTML = "<strong>Controles:</strong><br/>PC: <b>A/D</b> ou <b>‚Üê/‚Üí</b> ‚Ä¢ <b>Espa√ßo</b> = Turbo<br/>Celular: bot√µes + <b>arrastar</b> na tela";
      overlay.style.display = "none";
      dragTip.style.display = isCoarse ? "block" : "none";

      resetWorld();
      running = true;
      statusEl.textContent = "Correndo!";
    }

    function gameOver() {
      running = false;
      statusEl.textContent = "Game Over";
      dragTip.style.display = "none";

      const finalScore = Math.floor(score);
      best = Math.max(best, finalScore);
      localStorage.setItem("car_dodge_best", String(best));
      bestNote.textContent = `Melhor: ${best}`;

      titleEl.textContent = "Game Over!";
      line1El.innerHTML = `Seu score: <b>${finalScore}</b> ‚Ä¢ Melhor: <b>${best}</b>`;
      line2El.innerHTML = `Pressione <b>Enter</b> (PC) ou toque em <b>Jogar</b> para reiniciar.`;

      overlay.style.display = "flex";
    }

    function spawnObstacleAhead() {
      const o = getObstacle();
      const lane = lanes[(Math.random() * lanes.length) | 0];
      // spacing tightens with difficulty
      const spacing = THREE.MathUtils.lerp(8.2, 4.6, Math.min(difficulty / 22, 1));
      furthestZ -= spacing;

      o.position.set(lane, 0, furthestZ);
      o.rotation.set(0, 0, 0);
    }

    function circleHit(ax, az, ar, bx, bz, br) {
      const dx = ax - bx;
      const dz = az - bz;
      const rr = (ar + br);
      return (dx*dx + dz*dz) <= rr*rr;
    }

    playBtn.addEventListener("click", startGame);

    // ----------------- Resize -----------------
    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(Math.min(devicePixelRatio, dprCap));
      renderer.setSize(innerWidth, innerHeight);
    });

    // ----------------- Animation loop -----------------
    let lastT = performance.now();

    function tick(t) {
      const dt = Math.min((t - lastT) / 1000, 0.033);
      lastT = t;

      stars.rotation.y += dt * 0.02;

      if (running) {
        // difficulty ramps
        difficulty += dt * 0.35;
        const diffSpeed = 1 + Math.min(difficulty * 0.08, 0.9);

        // turbo
        const wantsTurbo = keys.turbo;
        if (wantsTurbo && turboEnergy > 0.06) turbo = true;
        else turbo = false;

        const turboBoost = turbo ? 1.55 : 1.0;
        speed = baseSpeed * diffSpeed * turboBoost;

        if (turbo) turboEnergy = Math.max(0, turboEnergy - dt * 0.55);
        else turboEnergy = Math.min(1, turboEnergy + dt * 0.25);

        // steering input (keys) ‚Äî drag overrides partially
        const input = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
        if (!dragging) {
          steer = THREE.MathUtils.clamp(input, -1, 1);
          laneX += steer * dt * 6.2;
          laneX = THREE.MathUtils.clamp(laneX, -2.7, 2.7);
        } else {
          // while dragging, apply a slight auto-centering smoothing
          steer = THREE.MathUtils.clamp(input * 0.4, -1, 1);
          laneX += steer * dt * 2.0;
          laneX = THREE.MathUtils.clamp(laneX, -2.7, 2.7);
        }

        // smooth car x + leaning
        car.position.x = THREE.MathUtils.lerp(car.position.x, laneX, 1 - Math.pow(0.001, dt));
        car.rotation.z = THREE.MathUtils.lerp(car.rotation.z, -car.position.x * 0.08, 1 - Math.pow(0.001, dt));
        car.rotation.y = THREE.MathUtils.lerp(car.rotation.y, steer * 0.06, 1 - Math.pow(0.001, dt));

        // wheel spin
        const wheelSpin = dt * speed * 0.9;
        w1.rotation.x += wheelSpin; w2.rotation.x += wheelSpin; w3.rotation.x += wheelSpin; w4.rotation.x += wheelSpin;

        // move world towards camera
        const dz = dt * speed;

        // road loop
        const roadLen = 26;
        for (const road of roadPieces) {
          road.position.z += dz;
          if (road.position.z > 18) road.position.z -= roadLen * roadPieces.length;
        }

        // lane lights loop
        const laneLoop = laneLightZSpacing * laneLightCount;
        for (const lm of laneLightMeshes) {
          lm.position.z += dz;
          if (lm.position.z > 8) lm.position.z -= laneLoop;
        }

        // obstacles move, spin, despawn
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const o = obstacles[i];
          o.position.z += dz;
          o.rotation.y += dt * o.userData.spin;
          o.rotation.x += dt * o.userData.spin * 0.5;

          // despawn behind
          if (o.position.z > 14) {
            obstacles.splice(i, 1);
            releaseObstacle(o);
          }
        }

        // maintain horizon ahead (fix spawn bug)
        // furthestZ also moves forward since world moves +z
        furthestZ += dz;
        while (Math.abs(furthestZ) < horizon) spawnObstacleAhead();

        // score
        score += dt * (8 + speed * 0.35);
        scoreEl.textContent = String(Math.floor(score));
        speedEl.textContent = String(Math.floor(speed));
        statusEl.textContent = turbo ? "TURBO!" : "Correndo!";

        // collision (more reliable)
        const carR = 0.80;
        for (const o of obstacles) {
          const dzc = Math.abs(o.position.z - car.position.z);
          if (dzc > 1.25) continue; // near zone only
          const hit = circleHit(car.position.x, car.position.z, carR, o.position.x, o.position.z, o.userData.radius);
          if (hit) { gameOver(); break; }
        }

        // camera follow
        const camTargetX = car.position.x * 0.35;
        camera.position.x = THREE.MathUtils.lerp(camera.position.x, camTargetX, 1 - Math.pow(0.001, dt));
        camera.position.z = THREE.MathUtils.lerp(camera.position.z, 10.2 - (turbo ? 0.9 : 0), 1 - Math.pow(0.001, dt));
        camera.lookAt(car.position.x * 0.15, 0.8, 0);
      } else {
        // idle
        car.rotation.y += dt * 0.25;
        under.material.opacity = 0.25 + Math.sin(performance.now() * 0.003) * 0.05;
        camera.lookAt(0, 0.8, 0);
      }

      // underglow feedback
      under.scale.setScalar(1.0 + (1 - turboEnergy) * 0.15);
      under.material.opacity = 0.28 + (turbo ? 0.18 : 0.0) + (1 - turboEnergy) * 0.06;

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
