<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corrida 3D - Evite os Obstáculos</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            padding: 20px;
        }
        
        .ui-panel {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: all;
        }
        
        #scorePanel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
        }
        
        #controlsPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
        }
        
        #startPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            text-align: center;
            z-index: 3;
        }
        
        #gameOverPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            text-align: center;
            z-index: 3;
            display: none;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff7e5f, #feb47b);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(255, 126, 95, 0.3);
        }
        
        h2 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #4dccbd;
        }
        
        h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #feb47b;
        }
        
        p {
            margin-bottom: 15px;
            line-height: 1.5;
            color: #ccc;
        }
        
        .score-display {
            font-size: 2rem;
            font-weight: bold;
            color: #4dccbd;
            text-shadow: 0 0 10px rgba(77, 204, 189, 0.5);
        }
        
        .high-score {
            font-size: 1.2rem;
            color: #ff7e5f;
            margin-top: 5px;
        }
        
        .btn {
            background: linear-gradient(90deg, #ff7e5f, #feb47b);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .btn i {
            margin-right: 8px;
        }
        
        .control-info {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            color: #ccc;
        }
        
        .key {
            display: inline-block;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 5px 10px;
            margin-right: 10px;
            font-family: monospace;
            min-width: 40px;
            text-align: center;
        }
        
        .difficulty-selector {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
        }
        
        .difficulty-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ccc;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            margin: 0 5px;
        }
        
        .difficulty-btn.active {
            background: linear-gradient(90deg, #4dccbd, #6ae2d3);
            color: white;
            border-color: #4dccbd;
        }
        
        .obstacle-counter {
            margin-top: 15px;
            font-size: 1.1rem;
            color: #feb47b;
        }
        
        #lives {
            display: flex;
            margin-top: 10px;
        }
        
        .life {
            color: #ff7e5f;
            font-size: 1.5rem;
            margin-right: 5px;
        }
        
        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            text-align: center;
        }
        
        .speed-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #4dccbd;
            text-shadow: 0 0 10px rgba(77, 204, 189, 0.5);
        }
        
        .speed-unit {
            font-size: 1.2rem;
            color: #ccc;
        }
        
        @media (max-width: 768px) {
            #scorePanel, #controlsPanel, #speedometer {
                width: 90%;
                left: 5%;
                right: 5%;
            }
            
            #scorePanel {
                top: 10px;
            }
            
            #controlsPanel {
                bottom: 10px;
            }
            
            #startPanel, #gameOverPanel {
                width: 90%;
            }
            
            .difficulty-selector {
                flex-direction: column;
            }
            
            .difficulty-btn {
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameCanvas"></div>
        
        <div id="uiOverlay">
            <div id="scorePanel" class="ui-panel">
                <h3>PONTUAÇÃO</h3>
                <div class="score-display" id="score">0</div>
                <div class="high-score">Recorde: <span id="highScore">0</span></div>
                <div class="obstacle-counter">Obstáculos evitados: <span id="obstaclesAvoided">0</span></div>
                <div id="lives">
                    <div class="life"><i class="fas fa-heart"></i></div>
                    <div class="life"><i class="fas fa-heart"></i></div>
                    <div class="life"><i class="fas fa-heart"></i></div>
                </div>
            </div>
            
            <div id="controlsPanel" class="ui-panel">
                <h3>CONTROLES</h3>
                <div class="control-info">
                    <div class="key">A</div>
                    <div class="key">←</div>
                    <span>Mover para ESQUERDA</span>
                </div>
                <div class="control-info">
                    <div class="key">D</div>
                    <div class="key">→</div>
                    <span>Mover para DIREITA</span>
                </div>
                <div class="control-info">
                    <div class="key">W</div>
                    <div class="key">↑</div>
                    <span>Acelerar</span>
                </div>
                <div class="control-info">
                    <div class="key">S</div>
                    <div class="key">↓</div>
                    <span>Desacelerar</span>
                </div>
                <div class="control-info">
                    <div class="key">ESPAÇO</div>
                    <span>Pausar/Continuar</span>
                </div>
            </div>
            
            <div id="speedometer" class="ui-panel">
                <h3>VELOCIDADE</h3>
                <div class="speed-value" id="speed">60</div>
                <div class="speed-unit">km/h</div>
            </div>
            
            <div id="startPanel" class="ui-panel">
                <h1><i class="fas fa-car"></i> CORRIDA 3D</h1>
                <h2>Evite os Obstáculos</h2>
                <p>Use as teclas de direção ou A/D para mover o carro e evitar os obstáculos na pista. Acelere com W e desacelere com S. Não bata nos obstáculos!</p>
                
                <div class="difficulty-selector">
                    <div class="difficulty-btn active" data-difficulty="easy">Fácil</div>
                    <div class="difficulty-btn" data-difficulty="medium">Médio</div>
                    <div class="difficulty-btn" data-difficulty="hard">Difícil</div>
                </div>
                
                <button id="startBtn" class="btn">
                    <i class="fas fa-play"></i> INICIAR JOGO
                </button>
            </div>
            
            <div id="gameOverPanel" class="ui-panel">
                <h1><i class="fas fa-car-crash"></i> FIM DE JOGO</h1>
                <h2 id="finalScoreTitle">Pontuação: 0</h2>
                <p id="gameOverMessage">Você colidiu com um obstáculo!</p>
                <button id="restartBtn" class="btn">
                    <i class="fas fa-redo"></i> JOGAR NOVAMENTE
                </button>
                <button id="menuBtn" class="btn">
                    <i class="fas fa-home"></i> VOLTAR AO MENU
                </button>
            </div>
        </div>
    </div>

    <script>
        // Variáveis do jogo
        let scene, camera, renderer, controls;
        let car, road, obstacles = [];
        let gameState = 'menu'; // menu, playing, paused, gameOver
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        let obstaclesAvoided = 0;
        let lives = 3;
        let speed = 60;
        let difficulty = 'easy';
        let moveDirection = 0;
        let lastObstacleTime = 0;
        let obstacleInterval = 1500; // ms entre obstáculos
        let roadSegments = [];
        let roadWidth = 20;
        let roadLength = 200;
        let keys = {};
        
        // Configurações de dificuldade
        const difficultySettings = {
            easy: { speed: 60, obstacleInterval: 1500, obstacleSpeed: 0.1, lives: 3 },
            medium: { speed: 80, obstacleInterval: 1200, obstacleSpeed: 0.15, lives: 3 },
            hard: { speed: 100, obstacleInterval: 900, obstacleSpeed: 0.2, lives: 3 }
        };
        
        // Inicialização do jogo
        function init() {
            // Configurar cena
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x16213e, 10, 200);
            
            // Configurar câmera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 15);
            camera.lookAt(0, 0, -10);
            
            // Configurar renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameCanvas').appendChild(renderer.domElement);
            
            // Configurar luzes
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            // Criar a pista
            createRoad();
            
            // Criar o carro
            createCar();
            
            // Configurar eventos
            setupEventListeners();
            
            // Atualizar recorde
            document.getElementById('highScore').textContent = highScore;
            
            // Iniciar loop de animação
            animate();
        }
        
        function createRoad() {
            // Criar pista principal
            const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
            const roadMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide
            });
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = Math.PI / 2;
            road.position.y = -0.5;
            road.receiveShadow = true;
            scene.add(road);
            
            // Adicionar marcações na pista
            for (let i = 0; i < 20; i++) {
                const lineGeometry = new THREE.PlaneGeometry(0.5, 2);
                const lineMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = Math.PI / 2;
                line.position.set(0, -0.4, -i * 10);
                scene.add(line);
            }
            
            // Adicionar laterais da pista
            const sideGeometry = new THREE.BoxGeometry(2, 1, roadLength);
            const sideMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
            
            const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
            leftSide.position.set(-roadWidth/2 - 1, 0, 0);
            scene.add(leftSide);
            
            const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
            rightSide.position.set(roadWidth/2 + 1, 0, 0);
            scene.add(rightSide);
            
            // Adicionar grama
            const grassGeometry = new THREE.PlaneGeometry(100, roadLength);
            const grassMaterial = new THREE.MeshPhongMaterial({ color: 0x2d5a27 });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = Math.PI / 2;
            grass.position.y = -0.51;
            scene.add(grass);
            
            // Adicionar céu
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }
        
        function createCar() {
            const carGroup = new THREE.Group();
            
            // Corpo do carro
            const carBodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const carBodyMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444 });
            const carBody = new THREE.Mesh(carBodyGeometry, carBodyMaterial);
            carBody.position.y = 0.5;
            carBody.castShadow = true;
            carGroup.add(carBody);
            
            // Teto do carro
            const carTopGeometry = new THREE.BoxGeometry(2, 0.8, 3);
            const carTopMaterial = new THREE.MeshPhongMaterial({ color: 0xff6666 });
            const carTop = new THREE.Mesh(carTopGeometry, carTopMaterial);
            carTop.position.y = 1.4;
            carTop.position.z = -0.5;
            carTop.castShadow = true;
            carGroup.add(carTop);
            
            // Rodas
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            
            for (let i = 0; i < 4; i++) {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                
                if (i < 2) {
                    wheel.position.x = -1.5;
                    wheel.position.y = 0.2;
                } else {
                    wheel.position.x = 1.5;
                    wheel.position.y = 0.2;
                }
                
                if (i % 2 === 0) {
                    wheel.position.z = -1.5;
                } else {
                    wheel.position.z = 1.5;
                }
                
                carGroup.add(wheel);
            }
            
            // Faróis
            const headlightGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const headlightMaterial = new THREE.MeshPhongMaterial({ color: 0xffffcc, emissive: 0xffffcc });
            
            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(-1, 0.5, 2.6);
            carGroup.add(leftHeadlight);
            
            const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlight.position.set(1, 0.5, 2.6);
            carGroup.add(rightHeadlight);
            
            carGroup.position.y = 0.5;
            scene.add(carGroup);
            car = carGroup;
        }
        
        function createObstacle() {
            const obstacleTypes = ['cone', 'barrel', 'box'];
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            
            let obstacle;
            
            if (type === 'cone') {
                const geometry = new THREE.ConeGeometry(0.8, 2, 8);
                const material = new THREE.MeshPhongMaterial({ color: 0xffaa00 });
                obstacle = new THREE.Mesh(geometry, material);
            } else if (type === 'barrel') {
                const geometry = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 16);
                const material = new THREE.MeshPhongMaterial({ color: 0xaa5500 });
                obstacle = new THREE.Mesh(geometry, material);
            } else {
                const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const material = new THREE.MeshPhongMaterial({ color: 0x6666ff });
                obstacle = new THREE.Mesh(geometry, material);
            }
            
            // Posicionar obstáculo aleatoriamente na pista
            const lanePositions = [-5, 0, 5];
            const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
            
            obstacle.position.x = lane;
            obstacle.position.z = -50; // Começa longe da vista
            obstacle.position.y = type === 'cone' ? 1 : 0.75;
            
            obstacle.castShadow = true;
            obstacle.userData = { type, speed: difficultySettings[difficulty].obstacleSpeed };
            
            scene.add(obstacle);
            obstacles.push(obstacle);
            
            // Adicionar partículas brilhantes ao redor do obstáculo
            const particleCount = 5;
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: type === 'cone' ? 0xffff00 : type === 'barrel' ? 0xff6600 : 0x6666ff,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Posicionar partícula aleatoriamente ao redor do obstáculo
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.5;
                particle.position.x = obstacle.position.x + Math.cos(angle) * radius;
                particle.position.y = obstacle.position.y + 0.5 + Math.random();
                particle.position.z = obstacle.position.z + Math.sin(angle) * radius;
                
                particle.userData = { originalY: particle.position.y, time: Math.random() * Math.PI * 2 };
                obstacle.userData.particles = obstacle.userData.particles || [];
                obstacle.userData.particles.push(particle);
                scene.add(particle);
            }
        }
        
        function setupEventListeners() {
            // Controles de teclado
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                // Pausar com espaço
                if (e.key === ' ' && gameState === 'playing') {
                    togglePause();
                }
                
                // Prevenir comportamento padrão para teclas de jogo
                if (['arrowleft', 'arrowright', 'arrowup', 'arrowdown', 'a', 'd', 'w', 's', ' '].includes(e.key.toLowerCase())) {
                    e.preventDefault();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // Controles de toque para dispositivos móveis
            let touchStartX = 0;
            let touchStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (gameState !== 'playing') return;
                
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                
                // Calcular diferença do toque
                const diffX = touchX - touchStartX;
                const diffY = touchStartY - touchY; // Inverter para cima = positivo
                
                // Mover carro baseado no deslize horizontal
                if (Math.abs(diffX) > 10) {
                    moveDirection = Math.sign(diffX) * 0.5;
                }
                
                // Ajustar velocidade baseado no deslize vertical
                if (Math.abs(diffY) > 10) {
                    speed = Math.min(150, Math.max(30, speed + diffY * 0.1));
                }
                
                e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchend', () => {
                moveDirection = 0;
            });
            
            // Botões da interface
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            document.getElementById('menuBtn').addEventListener('click', backToMenu);
            
            // Seletores de dificuldade
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    difficulty = this.dataset.difficulty;
                });
            });
            
            // Ajustar tamanho da tela
            window.addEventListener('resize', onWindowResize);
        }
        
        function startGame() {
            gameState = 'playing';
            score = 0;
            obstaclesAvoided = 0;
            speed = difficultySettings[difficulty].speed;
            lives = difficultySettings[difficulty].lives;
            obstacleInterval = difficultySettings[difficulty].obstacleInterval;
            
            // Remover obstáculos antigos
            obstacles.forEach(obstacle => {
                if (obstacle.userData.particles) {
                    obstacle.userData.particles.forEach(particle => scene.remove(particle));
                }
                scene.remove(obstacle);
            });
            obstacles = [];
            
            // Reposicionar carro
            car.position.x = 0;
            
            // Atualizar UI
            document.getElementById('startPanel').style.display = 'none';
            document.getElementById('gameOverPanel').style.display = 'none';
            updateLivesDisplay();
            updateScore();
        }
        
        function restartGame() {
            startGame();
        }
        
        function backToMenu() {
            gameState = 'menu';
            document.getElementById('gameOverPanel').style.display = 'none';
            document.getElementById('startPanel').style.display = 'block';
        }
        
        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
            } else if (gameState === 'paused') {
                gameState = 'playing';
            }
        }
        
        function updateLivesDisplay() {
            const livesElement = document.getElementById('lives');
            livesElement.innerHTML = '';
            
            for (let i = 0; i < 3; i++) {
                const life = document.createElement('div');
                life.className = 'life';
                if (i < lives) {
                    life.innerHTML = '<i class="fas fa-heart"></i>';
                } else {
                    life.innerHTML = '<i class="far fa-heart"></i>';
                }
                livesElement.appendChild(life);
            }
        }
        
        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('obstaclesAvoided').textContent = obstaclesAvoided;
            document.getElementById('speed').textContent = Math.round(speed);
        }
        
        function gameOver() {
            gameState = 'gameOver';
            
            // Atualizar recorde
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
            
            // Atualizar painel de fim de jogo
            document.getElementById('finalScoreTitle').textContent = `Pontuação: ${score}`;
            document.getElementById('gameOverMessage').textContent = 
                lives <= 0 ? "Você perdeu todas as vidas!" : "Você colidiu com um obstáculo!";
            document.getElementById('gameOverPanel').style.display = 'block';
        }
        
        function updateGame(deltaTime) {
            if (gameState !== 'playing') return;
            
            // Atualizar velocidade baseada nas teclas pressionadas
            if (keys['arrowup'] || keys['w']) {
                speed = Math.min(150, speed + 0.1);
            }
            if (keys['arrowdown'] || keys['s']) {
                speed = Math.max(30, speed - 0.2);
            }
            
            // Movimento lateral do carro
            if (keys['arrowleft'] || keys['a']) {
                moveDirection = -0.5;
            } else if (keys['arrowright'] || keys['d']) {
                moveDirection = 0.5;
            } else if (!keys['arrowleft'] && !keys['a'] && !keys['arrowright'] && !keys['d']) {
                // Reduzir movimento gradualmente quando nenhuma tecla está pressionada
                moveDirection *= 0.9;
                if (Math.abs(moveDirection) < 0.01) moveDirection = 0;
            }
            
            // Aplicar movimento ao carro
            car.position.x += moveDirection;
            car.position.x = Math.max(-7, Math.min(7, car.position.x));
            
            // Adicionar inclinação ao carro ao virar
            car.rotation.z = -moveDirection * 0.1;
            
            // Atualizar câmera para seguir o carro
            camera.position.x += (car.position.x - camera.position.x) * 0.05;
            camera.position.z = car.position.z + 15;
            
            // Gerar obstáculos
            const currentTime = Date.now();
            if (currentTime - lastObstacleTime > obstacleInterval) {
                createObstacle();
                lastObstacleTime = currentTime;
                
                // Aumentar dificuldade com o tempo
                if (obstacleInterval > 500) {
                    obstacleInterval -= 1;
                }
            }
            
            // Atualizar obstáculos
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                
                // Mover obstáculo em direção ao carro
                obstacle.position.z += speed * 0.02;
                
                // Atualizar partículas
                if (obstacle.userData.particles) {
                    obstacle.userData.particles.forEach(particle => {
                        particle.userData.time += deltaTime * 2;
                        particle.position.y = particle.userData.originalY + Math.sin(particle.userData.time) * 0.3;
                        particle.position.z = obstacle.position.z;
                    });
                }
                
                // Verificar colisão
                const distance = Math.sqrt(
                    Math.pow(car.position.x - obstacle.position.x, 2) + 
                    Math.pow(car.position.z - obstacle.position.z, 2)
                );
                
                if (distance < 2.5) {
                    // Colisão detectada
                    lives--;
                    updateLivesDisplay();
                    
                    // Remover obstáculo
                    if (obstacle.userData.particles) {
                        obstacle.userData.particles.forEach(particle => scene.remove(particle));
                    }
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                    
                    // Efeito de colisão (piscar tela)
                    document.body.style.backgroundColor = '#ff4444';
                    setTimeout(() => {
                        document.body.style.backgroundColor = '';
                    }, 100);
                    
                    if (lives <= 0) {
                        gameOver();
                    }
                }
                
                // Remover obstáculos que passaram do carro
                if (obstacle.position.z > 20) {
                    // Aumentar pontuação por evitar obstáculo
                    if (obstacle.position.z > 15) {
                        score += 10;
                        obstaclesAvoided++;
                        updateScore();
                    }
                    
                    // Remover obstáculo
                    if (obstacle.userData.particles) {
                        obstacle.userData.particles.forEach(particle => scene.remove(particle));
                    }
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }
            
            // Atualizar pontuação baseada na velocidade
            score += Math.floor(speed / 10);
            updateScore();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Loop de animação
        let lastTime = 0;
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            updateGame(deltaTime);
            
            // Animar rodas do carro
            if (car) {
                car.children.forEach(child => {
                    if (child.type === 'Mesh' && child.geometry.type === 'CylinderGeometry') {
                        child.rotation.x += speed * 0.01;
                    }
                });
            }
            
            renderer.render(scene, camera);
        }
        
        // Iniciar o jogo quando a página carregar
        window.addEventListener('load', init);
    </script>
</body>
</html>
